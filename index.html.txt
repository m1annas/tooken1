<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Three.js Fighting Game Prototype</title>

<style>
    body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: Arial, sans-serif;
    }

    /* HUD */
    #hud {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 80%;
        display: flex;
        justify-content: space-between;
        pointer-events: none;
    }

    .bar-container {
        width: 40%;
        height: 20px;
        background: #333;
        border: 2px solid #fff;
    }

    .health {
        height: 100%;
        width: 100%;
        background: lime;
        transition: width 0.2s;
    }

    #ko {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 80px;
        color: red;
        display: none;
    }

    #restart {
        position: absolute;
        top: 65%;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 30px;
        font-size: 20px;
        display: none;
        cursor: pointer;
    }
</style>
</head>

<body>

<div id="hud">
    <div class="bar-container">
        <div id="playerHealth" class="health"></div>
    </div>
    <div class="bar-container">
        <div id="enemyHealth" class="health"></div>
    </div>
</div>

<div id="ko">KO</div>
<button id="restart">Restart</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
// =====================
// SCENE SETUP
// =====================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050505);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// =====================
// LIGHTING
// =====================
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 10, 5);
scene.add(dirLight);

// =====================
// INFINITE GRID FLOOR
// =====================
const grid = new THREE.GridHelper(200, 100, 0x444444, 0x222222);
scene.add(grid);

// =====================
// FIGHTER FACTORY
// =====================
function createFighter(color) {
    const body = new THREE.Mesh(
        new THREE.BoxGeometry(1, 2, 1),
        new THREE.MeshStandardMaterial({ color })
    );
    body.position.y = 1;
    body.health = 100;
    body.velocity = new THREE.Vector3();
    body.onGround = true;
    body.attacking = false;
    return body;
}

const player = createFighter(0x00aaff);
const enemy = createFighter(0xff3333);

player.position.x = -5;
enemy.position.x = 5;

scene.add(player);
scene.add(enemy);

// =====================
// INPUT
// =====================
const keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
window.addEventListener("mousedown", attack);

// =====================
// GAME CONSTANTS
// =====================
const gravity = -0.03;
const speed = 0.12;
const jumpForce = 0.6;
const dodgeDistance = 1.5;
let gameOver = false;

// =====================
// ATTACK LOGIC
// =====================
function attack() {
    if (player.attacking || gameOver) return;

    player.attacking = true;

    // Simple hitbox check
    const distance = player.position.distanceTo(enemy.position);
    if (distance < 2.2) {
        enemy.health -= 10;
    }

    setTimeout(() => player.attacking = false, 300);
}

// =====================
// AI LOGIC
// =====================
let aiTimer = 0;
function enemyAI() {
    if (gameOver) return;

    const dir = player.position.clone().sub(enemy.position).normalize();
    enemy.position.add(dir.multiplyScalar(0.05));

    aiTimer++;
    if (aiTimer > 90) {
        aiTimer = 0;
        if (enemy.position.distanceTo(player.position) < 2.2) {
            player.health -= 8;
        }
    }
}

// =====================
// CAMERA (SIDE VIEW)
// =====================
function updateCamera() {
    const mid = player.position.clone().add(enemy.position).multiplyScalar(0.5);
    camera.position.set(mid.x, 6, mid.z + 12);
    camera.lookAt(mid);
}

// =====================
// HEALTH UI
// =====================
function updateHUD() {
    document.getElementById("playerHealth").style.width = player.health + "%";
    document.getElementById("enemyHealth").style.width = enemy.health + "%";
}

// =====================
// GAME OVER
// =====================
function checkKO() {
    if (player.health <= 0 || enemy.health <= 0) {
        gameOver = true;
        document.getElementById("ko").style.display = "block";
        document.getElementById("restart").style.display = "block";
    }
}

document.getElementById("restart").onclick = () => location.reload();

// =====================
// MAIN LOOP
// =====================
function animate() {
    requestAnimationFrame(animate);

    if (!gameOver) {
        // PLAYER MOVEMENT
        if (keys["w"]) player.position.x += speed;
        if (keys["s"]) player.position.x -= speed;
        if (keys["a"]) player.position.z += speed;
        if (keys["d"]) player.position.z -= speed;

        // JUMP
        if (keys["e"] && player.onGround) {
            player.velocity.y = jumpForce;
            player.onGround = false;
        }

        // DODGE
        if (keys["t"]) {
            player.position.z += dodgeDistance;
            keys["t"] = false;
        }

        // GRAVITY
        player.velocity.y += gravity;
        player.position.y += player.velocity.y;
        if (player.position.y <= 1) {
            player.position.y = 1;
            player.velocity.y = 0;
            player.onGround = true;
        }

        enemyAI();
        updateHUD();
        checkKO();
    }

    updateCamera();
    renderer.render(scene, camera);
}

animate();

// =====================
// RESIZE
// =====================
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
